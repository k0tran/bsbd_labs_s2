#import "template.typ": *
#show: lab.with(n: 2)

= Read commited

Для начала выберем две роли, подходящие для выполнения данной операции. Пусть это будет sales_role для совершения операции (INSERT в sales.sales) и staff_role для наблюдения за операцией.

#pic(img: "lab2/rc_1.png")[READ COMMITED транзакция]

При этом при попытке чтения из-под staff_role: 
#pic(img: "lab2/rc_2.png")[Чтение из роли staff_role]

Как и должно быть, изменения, внесенные транзакцией READ COMMITED не должны быть видимы другим пользоватям до того как они будут совершены. Теперь попробуем COMMIT:

#pic(img: "lab2/rc_3.png")[Запись из sales_role]
#pic(img: "lab2/rc_4.png")[Чтение staff_role после завершения транзакции]

#pagebreak()

= Repeatable read

#pic(img: "lab2/rr_1.png")[Запись из sales_role]
#pic(img: "lab2/rr_2.png")[Чтение staff_role до и после завершения транзакции]

Изоляция транзакции уровня REPEATABLE READ обеспечивает одинаковое чтени вне зависимости меняется ли таблица или нет во время произведения транзакции.

#pic(img: "lab2/rr_3.png")[Открываем транзакцию на staff_role, обязательно читаем]
#pic(img: "lab2/rr_4.png")[Добавляем запись с sales_role]
#pic(img: "lab2/rr_5.png")[Запись не видна из транзакции staff_role]

#pagebreak()

= Serializable

Исполняет паралелльные транзакции как будто бы они происходят отдельно.

#pic(img: "lab2/s_1.png")[Запись из sales_role]
#pic(img: "lab2/s_2.png")[Чтение staff_role до и после завершения транзакции]

В отличие если мы вставляем две строки с одинаковым primary key (или другим уникальным значением), то в случае REPEATABLE READ обе транзакции не выдадут ошибку до их завершения (COMMIT). А в случае SERIALIZABLE, ошибка будет на этапе попытки вставки.

#pagebreak()

#endhead[Заключение]
В данной лабораторной работе были рассмотрены такие важные аспекты PostgreSQ изоляция транзакций Также была произведена опытная проверка их функционирования.
